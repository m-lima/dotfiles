##################################################
# Sudo tee
##################################################
echo <string> | sudo tee <target>


##################################################
# Automatic login
##################################################

#~/.netrc registers server+user+password
#like so:

machine github.com
login <user>
password <password>

#or, for GitHub

machine github.com
login <token>


##################################################
# Services
##################################################

#Using upstart create a conf file under /etc/init/<service>.conf
#like so:
description "A webhook monitoring server for GitHub"
author "Marcelo Lima"

start on filesystem or runlevel [2345]
stop on shutdown

script

    echo $$ > /var/run/GitWebhook.pid
    exec [COMMAND] >> /var/log/GitWebhook.log 2>&1

end script

pre-start script
    echo -e "\e[32m[`date`] UpStart is starting GitWebhook\e[m" >> /var/log/GitWebhook.log
end script

pre-stop script
    rm /var/run/GitWebhook.pid
    echo -e "\e[32m[`date`] UpStart is stopping GitWebhook\e[m" >> /var/log/GitWebhook.log
end script

#Start end stop with

sudo service <service> start


##################################################
# Attach to log file
##################################################
tail -f <file>


##################################################
# SQLite3
##################################################
List tables:
	select name from sqlite_master where type='table';
List columns:
	pragma table_info(table);


##################################################
# Read line by line
##################################################
while IFS='' read -r line || [[ -n "$line" ]]; do echo $line; done < exposed.txt

##################################################
# Execute upon list
##################################################
for line in $(<COMMAND>); do <ACTION>; done

##################################################
# Run in background
##################################################
&>	# Redirect both stdout and stderr to ...
&!	# Dettach and unparent

##################################################
# Linux Distro Version
##################################################
lsb_release -a

##################################################
# SSH Tunnel
##################################################
ssh -N -C -v -L<WHATEVER_PORT>:<TARGET_HOST>:<TARGET_PORT> <TUNNEL_USER>@<TUNNEL_HOST>

# Then access localhost:<WHATEVER_PORT> to access <TARGET_HOST>:<TARGET_PORT> through <TUNNEL_HOST>

##################################################
# SSH Reverse Tunnel
##################################################
ssh -f -N -T '-R*:<PUBLIC_PORT_FOR_TUNNEL>:localhost:<LOCAL_PORT>' -p <PUBLIC_PORT> <PUBLIC_USER>@<PUBLIC_HOST>

# Note that to use *, add to /etc/ssh/sshd_config:
GatewayPorts yes

# If it is only between two computers use:
ssh -f -N -T '-R<WHATEVER_PORT>:localhost:<LOCAL_PORT>' -p <PUBLIC_PORT> <PUBLIC_USER>@<PUBLIC_HOST>

# This should be run in the target computer, not the tunnel (which runs only sshd)
# Example

# Target runs:
ssh -f -N -T -R2020:localhost:22 -p 2222 cool_user@cool_server
                ^ Arbitrary port that will be open on cool_server
                              ^ Port for target sshd
                                     ^ Port for the proxy server ssh
                                             ^ Proxy server ssh login

# Source runs:
ssh -o ProxyCommand='ssh -ax -W localhost:2020 -l cool_user cool_server -p 2222' -p 2020 target_user@localhost
                                  ^ Points to the reverse proxy (localhost and the first port)
                                                     ^ User on proxy server ssh
                                                                ^ Proxy server ssh
                                                                            ^ Port for proxy server ssh
                                                                                     ^ Reverse proxy port
                                                                                                ^ Reverse proxy

# -f Run in background
# -N Do not run remote commands (better performance)
# -T Disabe pseudoTTY

##################################################
# Change resolution
##################################################
xrandr --output VGA-1 --mode 1920x1080

##################################################
# Memcached
##################################################
stats items # Info about items
stats slabs # Info about the slabs (also, the number is the slab class)
stats cachedump <slab_class> <number_to_dumb> # Returns the keys for that slab
get <key> # Returns the value for the key

##################################################
# Private git repository
##################################################
On server:
git init --bare repo_name.git
On client:
git remote add origin ssh://user@host:port/full/path/to/repo_name.git

##################################################
# Wildcard TLS certificate
##################################################
T# o issue:
docker run -it --rm --name certbot \
  -v /nice/path/certbot/etc:/etc/letsencrypt \
  -v /nice/path/certbot/var:/var/lib/letsencrypt \
  certbot/certbot \
  certonly --manual -d '*.domain.com' -d domain.com \
  --preferred-challenges dns \
  --server https://acme-v02.api.letsencrypt.org/directory \
  --register-unsafely-without-email \
  --agree-tos --manual-public-ip-logging-ok

# To check the DNS during the process:
host -t txt _acme-challenge.domain.com

# Keys will be under /nice/path/certbot/etc/live/domain.com
